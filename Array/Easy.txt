
1.=======================================================================

class Solution {
    public boolean isPalindrome(int x) {
        // If the number is negative, return false
        // If the last digit is zero, return false
        if (x < 0 || x % 10 == 0 && x != 0) {
            return false;
        }

        int secondHalf = 0;
        while (x > secondHalf) {
            secondHalf = x % 10 + secondHalf * 10;
            x = x / 10;
        }
        // While first half > second half
        // To get the last digit, x % 10 (1221 % 10 = 1)
        // To get the Nnd to last digit, we can divide x / 10 (1221 / 10 = 122)in the first iteration, and then
        // get the value from doing x % 10 (122 % 10 = 2)

        // Multiply the previous digit by 10 (1 * 10) then add the most recent last digit, 1 * 10 + 2 = 12


        //if first half == second half, return true
        //if odd, if first half == second half / 10 return true

        return x == secondHalf || x == secondHalf / 10;
    }
}
====================================================================================
2.===========================13.ROMAN TO INTEGER ======================================
class Solution {
    public int romanToInt(String s) {
        int ans = 0, num = 0;
        for (int i = s.length()-1; i >= 0; i--) {
            switch(s.charAt(i)) {
                case 'I': num = 1; break;
                case 'V': num = 5; break;
                case 'X': num = 10; break;
                case 'L': num = 50; break;
                case 'C': num = 100; break;
                case 'D': num = 500; break;
                case 'M': num = 1000; break;
            }
            if (4 * num < ans) ans -= num;
            else ans += num;
        }
        return ans;
    }
}
===================================================================================
3.======================1929. Concatenation of Array===============================
class Solution {
    public int[] getConcatenation(int[] nums) {
        int[] ans = new int[2*nums.length];
        for(int i = 0 ; i < nums.length ; i++) {
            ans[i] = nums[i];
            ans[i + nums.length] = nums[i];
        }
        return ans;
    }
}
=====================================================================================
4.===================1480.Running Sum of 1d Array==================================
class Solution {
    public int[] runningSum(int[] nums) {
        for(int i=1; i<nums.length ; i++){
            nums[i]+=nums[i-1];
        }
        return nums;
    }
}
===================================================================================
5.==================== 1920. Build Array from Permutation==========================
public int[] buildArray(int[] nums) {
        int[] ans = new int[nums.length];

        for(int i=0;i<nums.length;i++){
            ans[i] = nums[nums[i]];
        }
        return ans;
 }
==================================================================================
6.=================2011. Final Value of Variable After Performing Operations======
class Solution {
    public int finalValueAfterOperations(String[] operations) {
        //WE INITIATED X HERE BECAUSE WE WOULN'T INVOLVE THIS X IN LOOP
        int x = 0;
        //HERE WE USED FOR EACH LOOP
        for(String i : operations){
            //USE SINGLE LINE STATEMENT LIKE THIS \\//IF SINGLE CHARACTER USE SINGLE QUOTES
            if (i.charAt(1) == '+') x++; //HERE ONLY WE DO ADDITION NOT CONSIDER PRE/POST INCREMENT
            else x--; //HERE ONLY WE SUBTRACT NOT CONSIDER PRE/POST INCREMENT
        }
        return x;
    }
}
===================================================================================
7.==================1470. Shuffle the Array=========================================
//HINT
// [ 11,   22, 33,  44,  55,        66,           77,           88,            99,       100      ]
// [ i=0, i=1, i=2, i=3, i=4,  0+5((i=0)+n), 0+6((i=1)+n), 0+7((i=2)+n), 0+8((i=3)+n), 0+9((i=4)+n)  ] // i is incrementing by 1 for each pass and here n =5 if //array size is even then n =10
// then we can use this hint
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] ans = new int[2*n];
        for(int i=0; i<n ;i++){
            ans[i*2] = nums[i];       // i*2 is EVEN INDEXED POSITION
            ans[i*2+1] = nums[i+n];   // i*2+1 is ODD INDEXED POSITION
        }
        return ans;
    }
}
===================================================================================
8.=====================1512. Number of Good Pairs==================================
class Solution {
    public int numIdenticalPairs(int[] nums) {
        int goodPairs = 0;
        for(int i=0; i<nums.length ;i++){
            for(int j=0; j<nums.length  ;j++){
                if(nums[i] == nums[j] && i<j) goodPairs++; // WE USED INCREMENT instead of { goodPairs = goodPairs +1 or goodPairs += 1 } ;
            }
        }
        return goodPairs;
    }
}
=====================================================================================
9.====================1672. Richest Customer Wealth==================================
class Solution {
    public int maximumWealth(int[][] accounts) {
        int max_wealth = 0;
        for (int i = 0; i < accounts.length; i++) {
            int wealth_sum = 0;
            for (int j = 0; j < accounts[i].length; j++)
                wealth_sum += accounts[i][j];
            if (wealth_sum > max_wealth) max_wealth = wealth_sum; //INSTEAD OF THIS WE CAN USE ALSO { Math.max(number1,number2); }
        }
        return max_wealth;
    }
}
======================================================================================
10.====================
class Solution {
    public int mostWordsFound(String[] sentences) {
        int maxNoWords = 0;
        for(int i =0; i<sentences.length ;i++){
          // THIS IS ARRAY OF WORDS { sentences[i].split(" ") }
            int wordsCount = sentences[i].split(" ").length;
            if(wordsCount>maxNoWords) maxNoWords = wordsCount;
        }
        return maxNoWords;


        
    }
}
====================================================================================
11.====================1431. Kids With the Greatest Number of Candies===============
class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> result = new ArrayList<>();
        int maxCandies = 0;

        for(int i=0; i<candies.length ;i++){
            if(candies[i] > maxCandies) maxCandies = candies[i];
        }
        
        for(int j=0; j<candies.length ;j++){
            //HERE I LEARNT THIS THING NEW USING TERNARY OPERATOR WISELY
            result.add(candies[j] + extraCandies >= maxCandies ? true:false); 
        } 
        return result;  
    }
}
=============================================================================================
12.===================1365. How Many Numbers Are Smaller Than the Current Number=============
//BRUTE FORCE APPROACH// SC=> O(N) & TC=> O(N^2)
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] answer = new int[nums.length];

        for(int i=0; i<nums.length ; i++){
            int count = 0;
            for(int j=0; j<nums.length ; j++ ){
                if( nums[i] > nums[j]){
                    answer[i] = ++count;
                }
            }
        }
        return answer;
        
    }
}
//OPTIMIZED APPROAACH// SC=> O(N)+O(N) = O(N) for storing the ARRAY and a map.
TC=> O(nlogn) + O(n) +O(n) = O(nlogn)where nlogn for sorting, n for traversing the vector two times.
https://medium.com/theleanprogrammer/how-many-numbers-are-smaller-than-the-current-number-a97921755aff
==========================================================================================================
13.========================1313. Decompress Run-Length Encoded List===================================
//MY SOLUTION
class Solution {
    public int[] decompressRLElist(int[] nums) {

        /*FROM PROBLEM WE OBSERVE THAT LOGIC IS
            1. Sum of the freq = Noof elements inthe output
                1.1 we need index positions of freq 0,2,4,6,8,10,.... (i=0; ;i+=2)
            2. We add Value in array freq times
            `   2.1 for loop i pointer assigning position index 1,3,5,7,9,.... (i=1;;i+=2)
                2.2 for loop j pointer adding elements in output 0,1,2,3,.... (j=0;;j++)
        */  
        //FINDING SUM OF FREQUENCY
        int freq = 0, currentIndex = 0 ;
        for(int i=0; i<nums.length ; i+=2){
            freq += nums[i];
        }
        //OUTPUT INT ARRAY
        int[] output = new int[freq];
        for(int i=1; i<nums.length; i+=2){
            for(int j=0; j<nums[i-1] ;j++){
                output[currentIndex++] = nums[i];
            }
        }
        return output;
        
    }
}

//BEST SOLUTION WITH SC = O ms
class Solution {
    public int[] decompressRLElist(int[] nums) {
      int arrlen = 0;
      for(int i=0;i<nums.length;i+=2)
        arrlen+=nums[i];
      int target[] = new int[arrlen];
      
      int start=0;
      for (int i=0;i<nums.length;i+=2) 
      {
        Arrays.fill(target, start, start + nums[i], nums[i + 1]);
        start+=nums[i];
      }
      return target;
    }
}
=======================================================================================================
14.======================1108. Defanging an IP Address===================================================
//MY SOLUTION
class Solution {
    public String defangIPaddr(String address) {
        return address.replace(".","[.]");
    }
}
//ALTERNATIVE SOLUTION JUST FOR LEARNING METHODS
class Solution {
    public String defangIPaddr(String address) {
        String s="";
        for(int i=0;i<address.length();i++){
            if(address.charAt(i)=='.')
            s=s+"[.]";
            else
            s+=address.charAt(i);
        }
        return s;
    }
}
=======================================================================================================
15.==========================771. Jewels and Stones====================================================
//MY SOLUTION//
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        //CREATE AN HASHSET
        HashSet<Character> hs = new HashSet<>();
        int stonesCount = 0;

        //filtering duplicates
        for(char ch1 : jewels.toCharArray()) hs.add(ch1);

        for(char ch2 : stones.toCharArray()) if(hs.contains(ch2)) stonesCount++;
    
        return stonesCount;
    }
}

                    ------------------------------------------
//OPTIMISED SOLUTION//
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count=0;
        for(char c:stones.toCharArray()){        //indexOf() method returns THE POSITION OF THE FIRST OCCURENCE OF SPECIFIED CHARACTER(S) IN A STRING
            if(jewels.indexOf(c)!=-1)count++;
        }
        return count;
    }
}
======================================================================================================================
16.================================1720. Decode XORed Array=================================================
//MY SOLUTION//
#Bit Manipulation #Array
class Solution {
    public int[] decode(int[] encoded, int first) {
        int[] arr = new int[encoded.length + 1];
        arr[0] = first;
        for(int i=0; i<encoded.length ;i++){
            arr[i+1] = encoded[i] ^ arr[i] ;
        }
        return arr;       
    }
}
======================================================================================================
17.============================1528. Shuffle String=================================================
//MY SOLUTION//
class Solution {
    public String restoreString(String s, int[] indices) {
        char[] str =  new char[indices.length];
        //ARRANGING CHARACTERS IN ORDER
        for(int i=0; i<indices.length ;i++){
            str[indices[i]] = s.charAt(i);  
        }
        return new String(str);
    }
}
18.==============================1389. Create Target Array in the Given Orde============================
//MY SOLUTION//
class Solution {
    public int[] createTargetArray(int[] nums, int[] index) {
        List<Integer> arr = new ArrayList<>();
            for(int i=0; i<nums.length; i++){
                arr.add(index[i],nums[i]);//ADD METHOD adds ELEMENTS IN THEIR //  
                //CORRECT POSITIONS
            }
            int[] target = new int[nums.length];
            for(int i=0; i<nums.length ;i++){
                target[i] = arr.get(i);
            }
            return target;        
    }
}

=========================================================================================================

